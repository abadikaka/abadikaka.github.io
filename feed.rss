<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content"><channel><title>üßîüèª Michael Abadi S. | üçé iOS Engineer | üè† Bangkok, üáπüá≠ Thailand | üá≤üá® Indonesian</title><description>Welcome to the official web of Michael</description><link>https://michaelabadi.com</link><language>en</language><lastBuildDate>Sat, 24 Oct 2020 14:11:46 +0700</lastBuildDate><pubDate>Sat, 24 Oct 2020 14:11:46 +0700</pubDate><ttl>250</ttl><atom:link href="https://michaelabadi.com/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">https://michaelabadi.com/articles/Simple-Protocol-SwiftUI</guid><title>Simple Protocol Oriented in SwiftUI in 5 minutes</title><description>Simple Protocol Oriented in SwiftUI in 5 minutes</description><link>https://michaelabadi.com/articles/Simple-Protocol-SwiftUI</link><pubDate>Sat, 24 Oct 2020 21:00:00 +0700</pubDate><content:encoded><![CDATA[<h1>Simple Protocol Oriented in SwiftUI in 5 minutes</h1><h3>Medium : <a href="https://medium.com/macoclock/simple-protocol-oriented-in-swiftui-in-5-minutes-dadbca1017fa">Simple Protocol Oriented in SwiftUI in 5 minutes</a></h3><p>SwiftUI is a really powerful language since it was born in 2019. In 2020 (WWDC) Apple did announce a lot of improvement on SwiftUI. However, there is rarely a topic discussed good practices on how to do we able to implement protocol-oriented programming in SwiftUI. There are a lot of articles out there however I guarantee to cover that in 5 minutes of your time. This article is suitable for those who are just starting to learn about iOS Programming !.</p><p>Our end goal is to be able to fetch the data (mock data) and map it into our List view in SwiftUI. The application is about showing a list of the football player names. Normally we able to put everything under one Struct view object. Now let us take a look 3 main layer we will discuss :</p><ol><li><strong>View Layer</strong> <br /><br /></li></ol><ol start="2"><li><strong>Business Logic Layer</strong> <br /><br /></li></ol><ol start="3"><li><strong>Entity Layer</strong></li></ol><p>We will start with the Entity Layer. In order to show the data to the view through the view model, we need a dummy model, that must conform to Identifiable protocol (mandatory from SwiftUI) in order to the view to be able to identify the difference for each row.</p><pre><code><span class="comment">// The dummy model</span>
<span class="keyword">struct</span> Player: <span class="type">Identifiable</span> {
    <span class="keyword">let</span> id: <span class="type">Int</span>
    <span class="keyword">let</span> name: <span class="type">String</span>
    <span class="keyword">let</span> number: <span class="type">Int</span>
}
</code></pre><p>Now let‚Äôs move to BL Layer. Basic knowledge, normally we will just have a single View Model handle everything however how about if we want to limit the caller to only able to know the datasource and action that available from the View Model ?. We can use protocol-oriented programming in this case.</p><pre><code><span class="comment">// The datasource</span>
<span class="keyword">protocol</span> ItemViewModelDatasource {
    <span class="keyword">var</span> data: [<span class="type">Player</span>] { <span class="keyword">get set</span> }
}

<span class="comment">// The action capabilities</span>
<span class="keyword">protocol</span> ItemViewModelAction {
    <span class="keyword">func</span> fetchItem()
    <span class="keyword">func</span> addPlayer(<span class="keyword">_</span> player: <span class="type">Player</span>)
}
</code></pre><p>Both protocols above are the interface of datasource and action for our view model later. Now after this, since we are building with SwiftUI, we do need a class that conforms to ObservableObject and have a @Publish property wrapper to the corresponding datasource.</p><pre><code><span class="comment">// Base model protocol</span>
<span class="keyword">protocol</span> ListViewModel: <span class="type">ObservableObject</span> {
    <span class="keyword">var</span> action: <span class="type">ItemViewModelAction</span> { <span class="keyword">get</span> }
    <span class="keyword">var</span> datasource: <span class="type">ItemViewModelDatasource</span> { <span class="keyword">get set</span> }
}
</code></pre><p>Above protocol is the interface of ListViewModel (which is a protocol) and we encapsulate and restrict it only to able to get the action and datasource (also give a setter capabilities for setting the bind-ed object). Now let make a full implementation on the view model class.</p><pre><code><span class="comment">// Real class implementation</span>
<span class="keyword">class</span> PlayerListViewModel: <span class="type">ListViewModel</span>, <span class="type">ItemViewModelAction</span>, <span class="type">ItemViewModelDatasource</span> {
    
    <span class="comment">// MARK: - Datasource</span>
    <span class="keyword">@Published var</span> data: [<span class="type">Player</span>] = []
    
    <span class="keyword">private lazy var</span> _datasource: <span class="type">ItemViewModelDatasource</span> = {
        <span class="keyword">return self</span>
    }()
    
    <span class="keyword">var</span> datasource: <span class="type">ItemViewModelDatasource</span> {
        <span class="keyword">get</span> {
            <span class="keyword">return</span> _datasource
        }
        <span class="keyword">set</span> {
            _datasource = newValue
        }
    }
    
    <span class="comment">// MARK: - Action</span>
    <span class="keyword">var</span> action: <span class="type">ItemViewModelAction</span> {
        <span class="keyword">return self</span>
    }
    
    <span class="keyword">func</span> fetchItem() {
        data = [
            <span class="type">Player</span>(id: <span class="number">1</span>, name: <span class="string">"G. Donnaruma"</span>, number: <span class="number">1</span>),
            <span class="type">Player</span>(id: <span class="number">2</span>, name: <span class="string">"Andrea Conti"</span>, number: <span class="number">12</span>),
            <span class="type">Player</span>(id: <span class="number">3</span>, name: <span class="string">"G. Bonaventura"</span>, number:<span class="number">5</span>),
            <span class="type">Player</span>(id: <span class="number">1</span>, name: <span class="string">"Zlatan Ibrahimovic"</span>, number: <span class="number">21</span>)
        ]
    }
    
    <span class="keyword">func</span> addPlayer(<span class="keyword">_</span> player: <span class="type">Player</span>) {
        data.<span class="call">append</span>(player)
    }
}
</code></pre><p>As you can see, the view model needs to conform to our ObservedObject protocol interface as well as the datasource and action interface. Don‚Äôt forget to put property wrapper @Published in front of the data property. This is a mandatory step since this wrapper functionality is to inform our view that this one is the data from the observable object wants to notify the listener.</p><pre><code><span class="keyword">struct</span> ContentView&lt;Model&gt;: <span class="type">View</span> <span class="keyword">where</span> <span class="type">Model</span>: <span class="type">ListViewModel</span> {
    
    <span class="keyword">@ObservedObject var</span> viewModel: <span class="type">Model</span>
    
    <span class="keyword">@State var</span> items: [<span class="type">String</span>] = [
        <span class="string">"G. Donnarumma"</span>,
        <span class="string">"Andrea Conti"</span>,
        <span class="string">"Jack Bonaventura"</span>,
        <span class="string">"Zlatan Ibrahimovic"</span>
    ]
    
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">NavigationView</span> {
            <span class="type">List</span> {
                <span class="type">ForEach</span>(items, id: \.<span class="keyword">self</span>) { item <span class="keyword">in</span>
                    <span class="type">Text</span>(<span class="string">"Item -</span> \(item)<span class="string">"</span>)
                }
            }
            .<span class="call">navigationBarTitle</span>(<span class="string">"AC Milan Player"</span>)
        }
    }
}
</code></pre><p>In the last step, we can create our simple view as above. When we declare the struct we need to put the generic Model type after the struct name, along with the supported type which is ListViewModel . This way we always guarantee that the model that is passed by the caller would always be a ListViewModel abstraction. In above code, we are still using local @State data which is items. Now we want to change it with the one from the view model through our abstraction. Here are the changes below :</p><pre><code><span class="keyword">struct</span> ContentView&lt;Model&gt;: <span class="type">View</span> <span class="keyword">where</span> <span class="type">Model</span>: <span class="type">ListViewModel</span> {
    
    <span class="keyword">@ObservedObject var</span> viewModel: <span class="type">Model</span>
    
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">NavigationView</span> {
            <span class="type">List</span> {
                <span class="type">ForEach</span>(viewModel.<span class="property">datasource</span>.<span class="property">data</span>.<span class="property">indices</span>, id:           \.<span class="keyword">self</span>) { index <span class="keyword">in</span>
                    <span class="type">Text</span>(<span class="string">"Item -</span> \(<span class="keyword">self</span>.<span class="property">viewModel</span>.<span class="property">datasource</span>.<span class="property">data</span>[index].name)<span class="string">"</span>)
                }
            }
            .<span class="call">onAppear</span> {
                <span class="keyword">self</span>.<span class="property">viewModel</span>.<span class="property">action</span>.<span class="call">fetchItem</span>()
            }
            .<span class="call">navigationBarTitle</span>(<span class="string">"AC Milan Player"</span>)
        }
    }
}
</code></pre><p>As you can see above, we are binding the List with data from the view model instead local state. Also we are triggering the query data from .onAppear method of the list to get the data. That‚Äôs all you need to make a good separation of view and bussiness logic in SwiftUI.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://michaelabadi.com/articles/Build-Builder-Pattern-Swift</guid><title>Bake a Builder Pattern in iOS</title><description>Bake a Builder Pattern in iOS.</description><link>https://michaelabadi.com/articles/Build-Builder-Pattern-Swift</link><pubDate>Sun, 18 Oct 2020 21:00:00 +0700</pubDate><content:encoded><![CDATA[<h1>Bake a Builder Pattern in iOS</h1><h3>Medium : <a href="https://medium.com/macoclock/bake-a-builder-pattern-in-ios-4684a3a7c71a">Bake Builder Pattern</a></h3><p>Have you ever have a problem when designing a system that has a similar foundation and capabilities however the ingredients to form the object would vary? We may end up with an easy solution by providing different parameters for each subclass. However, multiple subclasses that need to override the constructor might also have to own those unnecessary properties into its interface. There is one design pattern that also considered as Creational Design Pattern which Android Design pattern by default having this pattern. It called as Builder Pattern.</p><p>Of course, there are many ways to make it work on iOS. Let understanding the basic with what is Builder Pattern. Builder is a creational design pattern that lets you construct objects step by step per user requirement. The pattern allows you to produce different types and representations of an object using the same construction code. It refers to a declarative way to construct an object. Builder pattern can be included as Reactive Programming as well!</p><p>Let start with the common problem, ‚ÄúA Car Company‚Äù. Company ‚ÄúA‚Äù is a big brand company and it has multiple products to be made. This company will make a ‚ÄúCarA‚Äù until ‚ÄúCarE‚Äù. They do have 5 types of cars, start from a car with a single door, sports car, family car, SUV, and a truck. We can achieve this easily by extend a ‚ÄúCar‚Äù base class and has the subclasses to override the necessary function, but we will end up with tons of subclasses and, and new parameters and more and more. We can simplify it by having one Base Class that owns a huge constructor, however, those subclasses need to override the constructor with all of the parameters from possible combinations. The constructor with lots of parameters has its downside, not all the parameters are needed at all times.</p><h2><strong>SOLUTION: BUILDER PATTERN (THE CAR CONCEPT)</strong></h2><p>Yep, by using a builder pattern we eliminate that construction logic. The pattern will extract and define the behavior of construction into steps. We may have buildDoors, buildWheels, buildEngine, buildColor, buildExhaust. We don‚Äôt need to call every step if we don‚Äôt need it. If we do need to have another builder for another type of car with a different implementation of each step, we can make different builders and implement it in a different way!. For example, imagine a builder that builds a car from 4 sports wheel and 2 doors, a second one that builds everything with 4 normal wheel and 4 doors and a third one that uses 2 doors and a big wheel. By calling the same set of steps, you get a sports car from the first builder, a normal family car from the second, and a Sport SUV from the third. However, this would only work if the client code that calls the building steps is able to interact with builders using a common interface. We also able to escalate this by having another Manager class to manage the specific builder of the process of creating the car in the company</p><h2><strong>CODE</strong></h2><ol><li>Declarative Way</li></ol><pre><code><span class="comment">// This one is a SportCarBuilder for building a sport car
// We just need two properties of wheel and color that can be added and modified
// However for engine and door has been defined by SportCar class</span>
<span class="keyword">final class</span> SportCarBuilder {

    <span class="keyword">private var</span> wheel: <span class="type">Wheel</span> = <span class="type">Wheel</span>(type: .<span class="call">racing</span>(tyre20))
    <span class="keyword">private var</span> color: <span class="type">Color</span> = <span class="type">Color</span>(.<span class="dotAccess">red</span>)

    <span class="keyword">func</span> withColor(color: <span class="type">UIColor</span>) {
      <span class="keyword">self</span>.<span class="property">color</span> = <span class="type">Color</span>(color) 
    }
    
    <span class="keyword">func</span> withWheel(type: <span class="type">WheelType</span>) {
      <span class="keyword">self</span>.<span class="property">wheel</span> = <span class="type">Wheel</span>(type: type)
    }
    
    <span class="keyword">func</span> build() -&gt; <span class="type">SportCar</span> {
        <span class="keyword">return</span> <span class="type">SportCar</span>(wheel: wheel, color: color)
    }
}

<span class="comment">// This one is a SportCar class that subclass of the Car base class
// Car base class has 4 properties, this class will initialize through the base class with designated parameters that we define for SportCar</span>
<span class="keyword">final class</span> SportCar: <span class="type">Car</span> {
  <span class="keyword">init</span>(wheel: <span class="type">Wheel</span>, color: <span class="type">Color</span>) {
    <span class="keyword">super</span>.<span class="keyword">init</span>(doors: <span class="type">Door</span>(<span class="number">2</span>), engine: <span class="type">Engine</span>(<span class="type">V85000</span>), wheel: wheel, color: color)
  }
}

<span class="comment">// How to call :</span>
<span class="keyword">let</span> sportCar = <span class="type">SportCarBuilder</span>()
                .<span class="call">withColor</span>(color: .<span class="dotAccess">red</span>)
                .<span class="call">withWheel</span>(type: .<span class="dotAccess">normal</span>)
                .<span class="call">build</span>()
                
<span class="comment">// sportCar.wheel === .normal --&gt; Defined by user
// sportCar.engine === Engine(V85000) --&gt; Defined by SportCar implementation</span>
</code></pre><p>In the above code, it is pretty clear that when we want to get the sportCar Object, we can easily call the builder and add the necessary requirement/modifier into the builder. This way we are defining the behavior of what we want to the builder (declarative) without intervening with the implementation. SportCar also hides the Engine and Door properties from the Car base class because it will automatically be adjusted in the SportCar class instead.</p><ol><li>Closure / Block</li></ol><pre><code><span class="comment">// We reuse the above SportCarBuilder, we just change some interface
// Notice we instead are using the block for update the necessary properties</span>
<span class="keyword">class</span> SportCar {
  <span class="keyword">typealias</span> Builder = (builder: <span class="type">SportCarBuilder</span>) -&gt; <span class="type">Void</span>

  <span class="keyword">private init</span>(builder: <span class="type">SportCarBuilder</span>) {
    <span class="keyword">super</span>.<span class="keyword">init</span>(doors: <span class="type">Door</span>(<span class="number">2</span>), engine: <span class="type">Engine</span>(<span class="type">V85000</span>), wheel: builder.<span class="property">wheel</span>, color: builder.<span class="property">color</span>)
  }

  <span class="keyword">static func</span> make(with builderBlock: <span class="type">Builder</span>) -&gt; <span class="type">SportCar</span> {
    <span class="keyword">let</span> builder = <span class="type">SportCarBuilder</span>()
    <span class="call">builderBlock</span>(builder)
    <span class="keyword">return</span> <span class="type">SportCar</span>(builder: builder)
  }
}

<span class="comment">// This is the way we will use by defining the properties inside the block</span>
<span class="keyword">let</span> sportCar = <span class="type">SportCar</span>.<span class="call">make</span> { builder <span class="keyword">in</span>
  builder.<span class="property">color</span> = .<span class="dotAccess">red</span>
  builder.<span class="property">wheel</span> = .<span class="dotAccess">racing</span>
}
</code></pre><p>In the above code it is pretty straight forward, we will define the behavior we want through the completion block when we call the make function inside SportCar class. In most cases, the second way is used by Objective-C developer.</p><ol start="3"><li>Constructor Injection</li></ol><pre><code><span class="comment">// This is the base Car class that has all of the foundation materials to make a Car</span>
<span class="keyword">class</span> Car {
  <span class="keyword">let</span> doors: <span class="type">Door</span>
  <span class="keyword">let</span> wheel: <span class="type">Wheel</span>
  <span class="keyword">let</span> engine: <span class="type">Engine</span>
  <span class="keyword">let</span> color: <span class="type">Color</span>
  
  <span class="keyword">func</span> buildCar() -&gt; <span class="type">Car</span>
}

<span class="comment">// This is the subclass of Car which is a SportCar that has a private initializer
// Only bake the Car with the builder using a static function, however you can omit the static one and immediate using the constructor as well (your preference)</span>
<span class="keyword">final class</span> SportCar: <span class="type">Car</span> {
  <span class="keyword">private init</span>(builder: <span class="type">SportCarBuilder</span>) {
    <span class="keyword">let</span> door = <span class="type">Door</span>(<span class="number">2</span>)
    <span class="keyword">let</span> engine = <span class="type">Engine</span>(<span class="type">V85000</span>)
    <span class="keyword">let</span> wheel = builder.<span class="property">wheel</span>
    <span class="keyword">let</span> color = builder.<span class="property">color</span>
    <span class="keyword">super</span>.<span class="keyword">init</span>(doors: door, engine: engine, wheel: wheel, color: color)
  }
  
  <span class="keyword">static func</span> make(with builder: <span class="type">SportCarBuilder</span>) -&gt; <span class="type">SportCar</span> {
    <span class="keyword">return</span> <span class="type">SportCar</span>(builder: builder)
  }
}

<span class="comment">// This is the SportCarBuilder that just need color and wheel because the engine and the door will be automatically adjusted on the class who will use this by default</span>
<span class="keyword">struct</span> SportCarBuilder {
  <span class="keyword">let</span> color: <span class="type">Color</span>
  <span class="keyword">let</span> wheel: <span class="type">Wheel</span>
}

<span class="comment">// This is the factory class for creating the necessary car on the company
// User will just need this class to retrieve the final product they need</span>
<span class="keyword">final class</span> CarFactory {
  
  <span class="keyword">func</span> sportCar(with builder: <span class="type">SportCarBuilder</span>) -&gt; <span class="type">SportCar</span> {
    <span class="keyword">return</span> <span class="type">SportCar</span>.<span class="call">make</span>(builder: builder)
  }
  
  <span class="keyword">func</span> truckCar(with builder: <span class="type">TruckCarBuilder</span>) -&gt; <span class="type">TruckCar</span> {
    <span class="keyword">return</span> <span class="type">TruckCar</span>.<span class="call">make</span>(builder: builder)
  }
  
  <span class="keyword">func</span> SUVCar(with builder: <span class="type">SUVCarBuilder</span>) -&gt; <span class="type">SUVCar</span> {
    <span class="keyword">return</span> <span class="type">SUVCar</span>.<span class="call">make</span>(builder: builder)
  }
  
  <span class="keyword">func</span> familyCar(with builder: <span class="type">FamilyCarBuilder</span>) -&gt; <span class="type">FamilyCar</span> {
    <span class="keyword">return</span> <span class="type">FamilyCar</span>.<span class="call">make</span>(builder: builder)
  }
}
</code></pre><p>In the code above we can see that we do have CarFactory as a factory object that generates each car base on the Builder that the user wants to inject into the parameters. The user creates the necessary builder through their required constructor on the specific builder. SportCarBuilder doesn‚Äôt have engine properties because in the SportCar object that consumes the builder will automatically adjust the engine with the required engine only for a sport car. This way the specific requirement has been handled properly by the SportCar class.</p><p>Finally the conclusion, the goal of the builder pattern is to reduce the need to keep mutable state ‚Äî resulting in objects that are simpler and generally more predictable. By enabling objects to become stateless, they are usually much easier to test and debug ‚Äî since their logic consists only of ‚Äúpure‚Äù input &amp; output. There are other multiple pros to use the builder pattern, even though this is not iOS Common design pattern but we can achieve it. Remember, there is also some stuff to be considered before we go with the builder pattern. I will let you guys decide whether it is worth it or not for using this pattern on your project.</p><h3>Reference<br />:</h3><ol><li>https://refactoring.guru/design-patterns/builder/swift/example</li><li>https://spin.atomicobject.com/2015/11/02/objective-c-value-objects-mantle/</li><li>https://www.swiftbysundell.com/articles/using-the-builder-pattern-in-swift/</li></ol>]]></content:encoded></item><item><guid isPermaLink="true">https://michaelabadi.com/articles/Escalated-Pyramid-Testing</guid><title>Escalated Testing Pyramid</title><description>Escalated Testing Pyramid.</description><link>https://michaelabadi.com/articles/Escalated-Pyramid-Testing</link><pubDate>Mon, 21 Sep 2020 21:00:00 +0700</pubDate><content:encoded><![CDATA[<h1>Escalated Testing Pyramid</h1><h3>Medium : <a href="https://medium.com/@michaelabadi/escalated-testing-pyramid-5c05ed249155">Escalated Testing Pyramid</a></h3><p>As a normal software engineer, we always remember the rule of thumb of testing. We always heard the word of the testing pyramid which consists of 3 things :</p><ol><li><strong>Unit Testing</strong> <br /><br /></li></ol><ol start="2"><li><strong>Integration Testing</strong> <br /><br /></li></ol><ol start="3"><li><strong>UI Testing</strong><br /><br /></li></ol><img src="https://michaelabadi.com/items/article/pyramid.png" alt="Normal pyramid test"/><br /><br /><br /><br /><p><strong>Unit Testing</strong> is the foundation of your test suite that will be made up of unit tests. Your unit tests make sure that a certain unit (your subject under test or SUT) of your codebase works as intended. Unit tests have the narrowest scope of all the tests in your test suite. The number of unit tests in your test suite will largely outnumber any other type of test. Normally we test every single function of each class to be able to cover 100% test coverage which is impossible. Below is an example of UT in Swift</p><pre><code><span class="keyword">func</span> testMultiplication() {
   <span class="keyword">let</span> a = <span class="number">4</span>
   <span class="keyword">let</span> b = <span class="number">2</span>
   <span class="call">XCTAssert</span>(a * b, <span class="number">8</span>) 
}
</code></pre><p><strong>Integration Testing</strong> is another testing term for testing the integration or communication between each other component of the application such as database, networking, or another layer of an object that needs to integrate with each other. Here are a good explanation and example of Integration testing in swift by <a href=" https://www.swiftbysundell.com/articles/integration-tests-in-swift/">John Sundel</a>.</p><p><strong>UI Testing</strong> is the last layer which is the layer that facing the end-user directly, in this case, we normally call it as an end to end test. The most non-efficient way yet the most accurate is manual testing for UI Testing since it involves an interaction of human behavior which sometimes leads to the BDD testing concept. We will put our accessibility identifier for each UI Element to be able to detect the target component in automation.</p><p>Most of the time all of the basic three testings above are not enough, sometime the application is growing bigger and needs a more maintainable testing approach as well a more concise testing structure. Finally, most of the company try to embrace more testing and find more ways to make testing more precise. Escalation of Testing Pyramid consists of more structure. We can breakdown more into several structures. This is one of the enhanced testing pyramids that I found out. (Order start from the lowest point)</p><img src="https://michaelabadi.com/items/article/triangletest.png" alt="Enhanced testing"/><ol><li><strong>Unit Testing</strong> <br /><br /></li></ol><ol start="2"><li><strong>Snapshot Testing</strong> ‚Üí Acceptance Test <br /><br /></li></ol><ol start="3"><li><strong>Integration Testing</strong><br /><br /></li></ol><ol start="4"><li><strong>UI Local Testing</strong> ‚Üí System Test<br /><br /></li></ol><ol start="5"><li><strong>UI Mock Server Testing</strong> ‚Üí System Test<br /><br /></li></ol><ol start="6"><li><strong>E2E Testing</strong> ‚Üí Production environment<br /><br /></li></ol><p>What was the difference between the former pyramid? So this one we can see some enhancement such as <strong>Snapshot Testing</strong> and <strong>UI Testing</strong>. Besides that, some companies also put more additional tests like <strong>Contract testing and API Testing</strong> as well.</p><p><strong>Snapshot Testing</strong>: Snapshot testing is a testing method that takes the precedent state of the view and compares it with the latest state of the view, if there are some changes, it will tell us if the test is broken because of the snapshot mismatch. Normally this kind of test also considers an acceptance test. The way it works, the system will store the latest state of the view to the memory then later on when someone runs the test, it will compare the newest value with the stored value. It compare either the view hierarchy or the state of the logic within the view itself. Snapshot testing useful to remind the developer if we need to double-check on a specific page if it may break some old logic or cause some issues on it. If there is no issue and all parties accept it, we need to update the test with the newest state of that view. We can use the famous FBSnapshotTesting for snapshot tests in mobile development.</p><pre><code><span class="keyword">import</span> FBSnapshotTestCase 
<span class="keyword">class</span> FBSnapshotTestCaseSwiftTest: <span class="type">FBSnapshotTestCase</span> {  
    <span class="keyword">override func</span> setUp() {    
       <span class="keyword">super</span>.<span class="call">setUp</span>()    
       recordMode = <span class="keyword">false</span>  
    }   
    <span class="keyword">func</span> testExample() {    
       <span class="keyword">let</span> view = <span class="type">UIView</span>(frame: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">64</span>, height: <span class="number">64</span>))    
       view.<span class="property">backgroundColor</span> = <span class="type">UIColor</span>.<span class="property">blue</span>
       <span class="type">FBSnapshotVerifyView</span>(view)     
       <span class="type">FBSnapshotVerifyLayer</span>(view.<span class="property">layer</span>)
     }
}
</code></pre><p><strong>UI Local Testing and UI Mock Server Testing</strong>: This testing is also driven by the concept of BDD. Somehow we need to test UI behavior that may work with the domain model or the business logic. We may mock the object which is very useful rather than uses the real object for that test. It is called as <strong>TestDouble</strong> method which taking the Mock object to test the behavior of the flow instead of comparing the state of the real object at the end of the state (Old classic test look for the end state of the class, meanwhile mock test looking for the correct behavior flow of specific test with ignoring the end state within the state, as long as the behavior working perfectly). We can divide this state by using local object testing in our machine before we are using real mock objects from the server that can configurable by the QA. We may need a Docker setup and start our own server for mocking the response from the server and also mocking our domain model object into the test.</p><p><strong>E2E Testing</strong>: This is the last testing which is UI Testing. This one is using production data and environment and normally will be tested with manual QA for better precision.</p><h3>Reference<br /></h3><ol><li><a href="https://martinfowler.com/articles/practical-test-pyramid.html">Practical Test</a></li><li><a href=" https://martinfowler.com/bliki/TestDouble.html">Test Double</a></li></ol>]]></content:encoded></item><item><guid isPermaLink="true">https://michaelabadi.com/articles/MapView-Annotation-SwiftUI</guid><title>MapView Annotation SwiftUI</title><description>MapView Annotation SwiftUI.</description><link>https://michaelabadi.com/articles/MapView-Annotation-SwiftUI</link><pubDate>Fri, 11 Sep 2020 21:00:00 +0700</pubDate><content:encoded><![CDATA[<h1>MapView Annotation SwiftUI</h1><h3>Medium : <a href="https://medium.com/macoclock/mapview-swiftui-with-annotationview-and-coordinator-70a305cf657">Map View SwiftUI + Annotation</a></h3><p>SwiftUI is very powerful for building an interactive UI at a fast pace. However, there are a couple of limitations still there such as some native API from UIKit like MKMapView from MapKit or search bar and other UIKit API. I will provide a tutorial for making a MapView in SwiftUI by using UIViewRepresentable as well as putting callback to the SwiftUI if we have clicked the annotation.</p><p>Some quick knowledge about several items below:</p><ol><li>UIViewRepresentable : A wrapper for a UIKit view that you use to integrate that view into your SwiftUI view hierarchy</li><li>Coordinator : A SwiftUI view that represents a UIKit view controller can define a Coordinator type that SwiftUI manages and provides as part of the representable view‚Äôs context</li><li>MapKit : UIKit API for Map behavior such as MKMapView and Annotation View and other native Map behavior</li></ol><p>First of all, we need to make our Model for displaying the item inside the map. The model we can put title and it‚Äôs coordinate (latitude and longitude).</p><h2><strong>CODE</strong></h2><pre><code><span class="keyword">final class</span> Checkpoint: <span class="type">NSObject</span>, <span class="type">MKAnnotation</span> {
    <span class="keyword">let</span> title: <span class="type">String</span>?
    <span class="keyword">let</span> countryCode: <span class="type">String</span>?
    <span class="keyword">let</span> coordinate: <span class="type">CLLocationCoordinate2D</span>

    <span class="keyword">init</span>(title: <span class="type">String</span>?, countryCode: <span class="type">String</span>?, coordinate: <span class="type">CLLocationCoordinate2D</span>) {
        <span class="keyword">self</span>.<span class="property">title</span> = title
        <span class="keyword">self</span>.<span class="property">countryCode</span> = countryCode
        <span class="keyword">self</span>.<span class="property">coordinate</span> = coordinate
    }
}
</code></pre><p>In the code above, the Checkpoint class is a class that represent our map point in the view. Once this model has been created let‚Äôs move to the creation of MapView</p><p>Create a new struct of MapView and make it conform to UIViewRepresentable.</p><pre><code><span class="keyword">import</span> UIKit
<span class="keyword">import</span> MapKit
<span class="keyword">import</span> SwiftUI

<span class="keyword">struct</span> MapView: <span class="type">UIViewRepresentable</span> {
 
    <span class="comment">// 1.</span>
    <span class="keyword">var</span> annotationOnTap: (<span class="keyword">_</span> title: <span class="type">String</span>) -&gt; <span class="type">Void</span>
 
    <span class="comment">// 2.</span>   
    <span class="keyword">@Binding var</span> checkpoints: [<span class="type">Checkpoint</span>]
    
    <span class="comment">/// 3. Used internally to maintain a reference to a MKMapView
    /// instance when the view is recreated.</span>
    <span class="keyword">let</span> key: <span class="type">String</span>

    <span class="keyword">private static var</span> mapViewStore = [<span class="type">String</span> : <span class="type">MKMapView</span>]()
    
    <span class="comment">// 4.</span>
    <span class="keyword">func</span> makeUIView(context: <span class="type">Context</span>) -&gt; <span class="type">MKMapView</span> {
        <span class="keyword">if let</span> mapView = <span class="type">MapView</span>.<span class="property">mapViewStore</span>[key] {
            mapView.<span class="property">delegate</span> = context.<span class="property">coordinator</span>
            <span class="keyword">return</span> mapView
        }
        <span class="keyword">let</span> mapView = <span class="type">MKMapView</span>(frame: .<span class="dotAccess">zero</span>)
        mapView.<span class="property">delegate</span> = context.<span class="property">coordinator</span>
        <span class="type">MapView</span>.<span class="property">mapViewStore</span>[key] = mapView
        <span class="keyword">return</span> mapView
    }

    <span class="comment">// 5.</span>
    <span class="keyword">func</span> updateUIView(<span class="keyword">_</span> uiView: <span class="type">MKMapView</span>, context: <span class="type">Context</span>) {
        uiView.<span class="call">addAnnotations</span>(checkpoints)
    }
    
    <span class="comment">// 6.</span>
    <span class="keyword">func</span> makeCoordinator() -&gt; <span class="type">MapCoordinator</span> {
        <span class="type">MapCoordinator</span>(<span class="keyword">self</span>)
    }
}
</code></pre><ol><li>AnnotationOnTap is a completion to notify SwiftUI if we have clicked an annotation from MKMapView</li><li>@Binding is a property wrapper for checkpoints model that we need for this MapView for displaying each dot of the location</li><li>This key is for storing a single MKMapView instance in the memory. Using mapViewStore for handling if there is an existing instance of MKMapView on this particular screen. Why do we need this? There is a bug on MKMapView (UIKit) if we move to another screen and SwiftUI rerendering the struct of the SwiftUI View that contains this MapView it will create new MapView instead of reusing it while the old one still on the memory. It causes some bottleneck on rendering UI part for both SwiftUI and UIKit on the same point and it can cause a crash after several times.</li><li>This one overriding function from UIViewRepresentable to return the expected view</li><li>This one overriding function from UIViewRepresentable to attach a new view or do some additional layouting. In this case, we add the checkpoint to each annotation</li><li>This one also overriding function form UIViewRepresentable for coordinator which for mapping the delegation logic on MKMapViewDelegate</li></ol><p>Okay once that view has been set up, now we can make the logic for notifying back to SwiftUI. We can not apply delegate in SwiftUI, so there is a Coordinator to put the business logic layer of pure Swift logic. Let make the MapCoordinator class.</p><pre><code><span class="keyword">final class</span> MapCoordinator: <span class="type">NSObject</span>, <span class="type">MKMapViewDelegate</span> {    <span class="comment">// 1.</span>
    <span class="keyword">var</span> parent: <span class="type">MapView</span>

    <span class="keyword">init</span>(<span class="keyword">_</span> parent: <span class="type">MapView</span>) {
        <span class="keyword">self</span>.<span class="property">parent</span> = parent
    }
    
    <span class="keyword">deinit</span> {
        <span class="call">print</span>(<span class="string">"deinit: MapCoordinator"</span>)
    }    <span class="comment">// 2.</span>    
    <span class="keyword">func</span> mapView(<span class="keyword">_</span> mapView: <span class="type">MKMapView</span>, didSelect view: <span class="type">MKAnnotationView</span>) {
        view.<span class="property">canShowCallout</span> = <span class="keyword">true

        let</span> btn = <span class="type">UIButton</span>(type: .<span class="dotAccess">detailDisclosure</span>)
        view.<span class="property">rightCalloutAccessoryView</span> = btn
    }
    
    <span class="comment">// 3.</span>    
    <span class="keyword">func</span> mapView(<span class="keyword">_</span> mapView: <span class="type">MKMapView</span>, annotationView view: <span class="type">MKAnnotationView</span>, calloutAccessoryControlTapped control: <span class="type">UIControl</span>) {
        <span class="keyword">guard let</span> capital = view.<span class="property">annotation</span> <span class="keyword">as</span>? <span class="type">Checkpoint</span>, <span class="keyword">let</span> placeName = capital.<span class="property">title</span> <span class="keyword">else</span> { <span class="keyword">return</span> }
        parent.<span class="call">annotationOnTap</span>(placeName)
    }
    
}
</code></pre><ol><li>We need a reference to the MKMapView here for the coordinator able to return back the handler/logic we attach on it</li><li>This one is the delegate function from MKMapView (Put MKMapViewDelegate on this class as well) for displaying the rightCalloutAccesoryView</li><li>This one is for telling if we click on the accessory control and we will return back the placeName through the handler on the MapView</li></ol><p>Once this has been set up now we can easily use the MapView on our SwiftUI.</p><pre><code><span class="keyword">struct</span> SearchView: <span class="type">View</span> {

    <span class="keyword">@ObservedObject var</span> viewModel: <span class="type">SearchViewModel</span> = <span class="type">SearchViewModel</span>()    
    
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">VStack</span> {
                <span class="type">MapView</span>(annotationOnTap: { title <span class="keyword">in</span>
                    <span class="call">print</span>(<span class="string">"Title clicked"</span>, title)
                }, checkpoints: $viewModel.<span class="property">checkpoints</span>, key: <span class="string">"SearchView"</span>)
                    .<span class="call">frame</span>(height: <span class="type">UIScreen</span>.<span class="property">main</span>.<span class="property">bounds</span>.<span class="property">height</span>)
                    .<span class="call">offset</span>(x: <span class="number">0</span>, y: <span class="number">350</span>)
            }
    }}
</code></pre><p>As you can see above we just need to pass the checkpoints model and key (can be anything) and viola, we can get the MapView working.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://michaelabadi.com/articles/Wrapper-Pattern-Swift-In-5-Minutes</guid><title>Wrapper Pattern Swift in 5 minutes</title><description>Understanding one of Wrapper Pattern (Adapter) in Real world use case.</description><link>https://michaelabadi.com/articles/Wrapper-Pattern-Swift-In-5-Minutes</link><pubDate>Fri, 11 Sep 2020 21:00:00 +0700</pubDate><content:encoded><![CDATA[<h1>Wrapper Pattern Swift in 5 minutes</h1><h3>Medium : <a href="https://medium.com/macoclock/wrapper-pattern-swift-in-5-minutes-d79f5b5793df">Wrapper pattern swift in 5 minutes</a></h3><p>Have you ever heard about the problem that you need to separate two modules working independently without knowing each other implementation, but requires to be able to communicate easily by only sending necessary data? Most of the advanced use cases will face this real-world use case and we require a more advanced design pattern to be able to solve this pattern to give more scalability to the project.</p><p>There is a general concept about ‚ÄúWrapping‚Äù an object through an intermediary class that can adapt to each other. A lot of structural design pattern that handles this problem. There are five most common design patterns that able to solve this problem, state as below:</p><ol><li><strong>Proxy</strong> could be used when you want to lazy-instantiate an object or hide the fact that you‚Äôre calling a remote service or control access to the object<br /><br /></li></ol><ol start="2"><li><strong>Decorator</strong> is also called ‚ÄúSmart Proxy.‚Äù This is used when you want to add functionality to an object, but not by extending that object‚Äôs type. This allows you to do so at runtime<br /><br /></li></ol><ol start="3"><li><strong>Adapter</strong> is used when you have an abstract interface, and you want to map that interface to another object which has a similar functional role, but a different interface<br /><br /></li></ol><ol start="4"><li><strong>Bridge</strong> is very similar to Adapter, but we call it Bridge when you define both the abstract interface and the underlying implementation. I.e. you‚Äôre not adapting to some legacy or third-party code, you‚Äôre the designer of all the code but you need to be able to swap out different implementations.<br /><br /></li></ol><ol start="5"><li><strong>Facade</strong> is a higher-level (read: simpler) interface to a subsystem of one or more classes. Suppose you have a complex concept that requires multiple objects to represent. Making changes to that set of objects is confusing because you don‚Äôt always know which object has the method you need to call. That‚Äôs the time to write a Facade that provides high-level methods for all the complex operations you can do to the collection of objects<br /><br /></li></ol><p>We can either choose one of the above general pattern to solve our case, and all of them basically is a wrapper pattern, however depending on the use case, this time I will cover about Adapter pattern (which widely used by many developers) to solve compatibility to communicate with 2 or more services on a different layer.</p><h2><strong>REAL-WORLD USE CASE</strong></h2><p>Once upon a time, I have a requirement to satisfy our client by making a framework to hide our internal solution toward our Messaging service through a beautiful interface, therefore I created an UIKit SDK. Next, they would like to integrate our UIKit, however not every of our functionality, some of them, which is we called as a component, would like to reuse it and can comply with their own UI and data source without interfering our business logic. So how do we need to solve this case? We will create a solution that we can provide them a way that they can integrate their own data sources of both UI and model with our framework as well hid the complexity behind. In this article, I would like to limit it only to our messaging list UI. See the below picture to help you understand more of the solution with the adapter.</p><img src="https://michaelabadi.com/items/article/wrapper.png" alt="Structure of our solution"/><h2><strong>CODE</strong></h2><p>Okay, let start to code. First, let limit what are the things that the client is able to inject and communicate to us. We want to limit them only able to set the number of messages, the UI configuration settings such as background color and text color of the list, and the row cell UI for each message in the list.</p><pre><code><span class="keyword">import</span> Foundation
<span class="keyword">import</span> UIKit
<span class="comment">// 1.</span>
<span class="keyword">public struct</span> MessageUIConfig {
   <span class="keyword">let</span> backgroundColor: <span class="type">UIColor</span>
   <span class="keyword">let</span> textColor: <span class="type">UIColor</span>
}
<span class="comment">// 2.</span>
<span class="keyword">public struct</span> MessageModel {
   <span class="keyword">let</span> id: <span class="type">String</span>
   <span class="keyword">let</span> text: <span class="type">String</span>
}
<span class="comment">// 3.</span>
<span class="keyword">public protocol</span> MessageCellable <span class="keyword">where</span> <span class="type">Self</span>: <span class="type">UITableViewCell</span> {
   <span class="keyword">var</span> cellReuseIdentifier: <span class="type">String</span> { <span class="keyword">get</span> }
   <span class="keyword">var</span> nib: <span class="type">UINib</span> { <span class="keyword">get</span> }
}
<span class="comment">// 4.</span>
<span class="keyword">public protocol</span> MessageDatasource {
   <span class="keyword">func</span> numberOfMessages() -&gt; <span class="type">Int</span>
   <span class="keyword">func</span> messagesForIndex(<span class="keyword">_</span> index: <span class="type">Int</span>) -&gt; <span class="type">MessageModel</span>
}
<span class="comment">// 5.</span>
<span class="keyword">public protocol</span> MessageAdapterDelegate {
   <span class="keyword">func</span> messageDidClick(<span class="keyword">_</span> cell: <span class="type">UITableViewCell</span>, message: <span class="type">MessageModel</span>)
   <span class="keyword">func</span> messageWillDisplay(<span class="keyword">_</span> cell: <span class="type">UITableViewCell</span>, message: <span class="type">MessageModel</span>)
}
<span class="comment">// 6.</span>
<span class="keyword">public class</span> MessageAdapter {
   <span class="keyword">weak var</span> delegate: <span class="type">MessageAdapterDelegate</span>?
   <span class="keyword">private(set) var</span> config: <span class="type">MessageUIConfig</span>!
   <span class="keyword">private(set) var</span> datasource: <span class="type">MessageDatasource</span>!
   <span class="keyword">init</span>(config: <span class="type">MessageUIConfig</span>, datasource: <span class="type">MessageDatasource</span>) {
    <span class="keyword">self</span>.<span class="property">config</span> = config
    <span class="keyword">self</span>.<span class="property">datasource</span> = datasource
  }
}
</code></pre><ol><li><strong>MessageUIConfig</strong> : This struct represents the configuration of the UI that will be used in the view of our SDK framework<br /><br /></li></ol><ol start="2"><li><strong>MessageModel</strong> : This one is a model of the message that the client needs to inject<br /><br /></li></ol><ol start="3"><li><strong>MessageCellable</strong> : This protocol represents custom cell if the client wants to use their own UITableViewCell and their own cell identifier. The protocol that wants to conform this one need to be an UITableViewCell and has an UINib from their bundle so our SDK can recognize<br /><br /></li></ol><ol start="4"><li><strong>MessageDatasource</strong> : The datasource needed for our SDK which is the number of messages loaded as well finding the message for the specific index in the table view<br /><br /></li></ol><ol start="5"><li><strong>MessageAdapterDelegate</strong> : Pretty clear this delegate for sending back out the action from our side to the client<br /><br /></li></ol><ol start="6"><li><strong>MessageAdapter</strong> : The main actor, which is the wrapper class for communication from client to us, providing the necessary configuration such as UI and datasource<br /><br /></li></ol><p><em>TIPS : You can also opt-out the UITableViewCell, instead ask client about what kind of UIView they want to inject and we can add it as subview of our own tableviewcell of the message.</em><br /><br /> <em>NOTE : I put public access specifier because I intend to make this as a public framework so client need to be able access it.</em></p><p>Once it is done, then we can go to write our implementation for exposing data to the client. Open your ViewController then look at the code below :</p><pre><code><span class="keyword">public class</span> ViewController: <span class="type">UIViewController</span>, <span class="type">UITableViewDataSource</span>, <span class="type">UITableViewDelegate</span> {
    
    <span class="comment">// If nil then we assume that we use predefined cell type</span>
    <span class="keyword">var</span> cell: <span class="type">MessageCellable</span>?
    
    <span class="comment">// NOTE: You should connect to IBOutlet, this just an example for the sake of the article</span>
    <span class="keyword">var</span> tableView: <span class="type">UITableView</span>!

    <span class="comment">// 1.</span>
    <span class="keyword">var</span> adapter: <span class="type">MessageAdapter</span>!
    <span class="keyword">override func</span> viewDidLoad() {
       <span class="keyword">super</span>.<span class="call">viewDidLoad</span>()
       <span class="comment">// 2.</span>
       tableView.<span class="call">register</span>(cell?.<span class="property">nib</span>, forCellReuseIdentifier: cell?.<span class="property">cellReuseIdentifier</span> ?? <span class="string">""</span>)
       tableView.<span class="property">delegate</span> = <span class="keyword">self</span>
       tableView.<span class="property">dataSource</span> = <span class="keyword">self</span>
       <span class="comment">// 3.</span>
       tableView.<span class="property">backgroundColor</span> = adapter.<span class="property">config</span>.<span class="property">backgroundColor</span>
    }
    
    <span class="keyword">func</span> tableView(<span class="keyword">_</span> tableView: <span class="type">UITableView</span>, numberOfRowsInSection section: <span class="type">Int</span>) -&gt; <span class="type">Int</span> {
      <span class="comment">// 4.</span>
      <span class="keyword">return</span> adapter.<span class="property">datasource</span>.<span class="call">numberOfMessages</span>()
    }
    
    <span class="keyword">func</span> tableView(<span class="keyword">_</span> tableView: <span class="type">UITableView</span>, cellForRowAt indexPath: <span class="type">IndexPath</span>) -&gt; <span class="type">UITableViewCell</span> {
       <span class="keyword">return</span> tableView.<span class="call">dequeueReusableCell</span>(withIdentifier: cell?.<span class="property">cellReuseIdentifier</span> ?? <span class="string">""</span>, for: indexPath)
    }
    
    <span class="keyword">func</span> tableView(<span class="keyword">_</span> tableView: <span class="type">UITableView</span>, didSelectRowAt indexPath: <span class="type">IndexPath</span>) {
       <span class="keyword">let</span> cell = tableView.<span class="call">cellForRow</span>(at: indexPath)
       <span class="comment">// 5.</span>
       <span class="keyword">let</span> messageModel = adapter.<span class="property">datasource</span>.<span class="call">messagesForIndex</span>(indexPath.<span class="property">item</span>)
       adapter.<span class="property">delegate</span>?.<span class="call">messageDidClick</span>(cell!, message: messageModel)
    }
    
    <span class="keyword">func</span> tableView(<span class="keyword">_</span> tableView: <span class="type">UITableView</span>, willDisplay cell: <span class="type">UITableViewCell</span>, forRowAt indexPath: <span class="type">IndexPath</span>) {
       <span class="comment">// 6.</span>
       <span class="keyword">let</span> messageModel = adapter.<span class="property">datasource</span>.<span class="call">messagesForIndex</span>(indexPath.<span class="property">item</span>)
       adapter.<span class="property">delegate</span>?.<span class="call">messageWillDisplay</span>(cell, message: messageModel)
    }
}
</code></pre><ol><li>Reference the adapter into client side. When client wants to reuse the stuff from us, they need to inject the adapter here either through constructor or property injection or method injection<br /><br /></li></ol><ol start="2"><li>Register the custom cell from the client, right now let assume if it exists then we can register it like this base on the protocol we define for them. Later on, we can optimize it by having a default cell view for the message list, if the client decides to not use our built-in cell<br /><br /></li></ol><ol start="3"><li>Example of usage of custom UI configuration from the adapter. We can optimize by having a default value<br /><br /></li></ol><ol start="4"><li>Number of datasource here which is the message is coming from the client datasource<br /><br /></li></ol><ol start="5"><li>Pretty clear this one example we send back the signal to the client regarding the action from us<br /><br /></li></ol><ol start="6"><li>Example of sending back the message model per index from the rendered list in our table view<br /><br /></li></ol><p><em>TIPS : You can always optimize the optional one with the default value.</em><br /><br /></p><p>Now let see how it works from the client POV. As a client what we need to do is create our MessageModel (In case we don‚Äôt want to reuse our SDK logic) as well the Adapter and inject it when we want to instantiate and push the VC from our UIKit.</p><pre><code><span class="keyword">import</span> CustomUIKit <span class="comment">// Name this base on your own framework
// 1. Make the adapter, message model, and so on. Assuming you already have your own class that conform to MessageDatasource and has MessageModel inside, so that should be fine</span>

<span class="keyword">let</span> config = <span class="type">MessageUIConfig</span>(backgroundColor: .<span class="dotAccess">red</span>, textColor: .<span class="dotAccess">blue</span>)
<span class="keyword">let</span> datasource = <span class="type">OwnMessageDatasource</span>() <span class="comment">// Must conform to MessageDatasource</span>
<span class="keyword">let</span> adapter = <span class="type">MessageAdapter</span>(config: config, datasource: datasource)

<span class="comment">// 2. Call the SDK VC, inject the adapter and push it to current nav controller</span>
<span class="keyword">let</span> vc = <span class="type">ViewController</span>.<span class="call">makeInstance</span>(adapter: customAdapter)
<span class="comment">// vc.adapter = adapter</span>
navigationController?.<span class="call">pushViewController</span>(vc, animated: <span class="keyword">true</span>)

</code></pre><ol><li>Create your own adapter and inject the custom config and datasource<br /><br /></li></ol><ol start="2"><li>Call the UIKit SDK public ViewController and call the static function of makeInstance that inject the adapter and return the ViewController. Another approach is putting property injection like the code below. All depend on your own approach to tackle client issues<br /><br /></li></ol><p>Viola! Done. Assuming you already set up all necessarily required protocol and inject it correctly then you will be fine. You can also optimize and customize the class from your own side before deploying it to the client. I would suggest to always limit what the client can customize, without also making them do the hard work.</p><h3>Reference<br /></h3><ol><li>Refactoring Guru (High recommended book to buy)</li><li><a href=" https://stackoverflow.com/questions/350404/how-do-the-proxy-decorator-adapter-and-bridge-patterns-differ/7211706">Stack overflow</a></li></ol>]]></content:encoded></item><item><guid isPermaLink="true">https://michaelabadi.com/articles/Build-Static-Website-Swift-John-Sundell-publish</guid><title>Get started with John Sundell's Publish (From Leonte.dev)</title><description>How to get started building a static website using Swift's Publish library by John Sundell.</description><link>https://michaelabadi.com/articles/Build-Static-Website-Swift-John-Sundell-publish</link><pubDate>Thu, 16 Jan 2020 15:14:00 +0700</pubDate><content:encoded><![CDATA[<h1>Get started with John Sundell's Publish (From Leonte.dev)</h1><h3>Original article : <a href="https://www.leonte.dev/articles/build-static-website-swift-john-sundell-publish/">build-static-website-swift-john-sundell-publish</a></h3><h2>Install Publish</h2><p>Run in Terminal</p><pre><code>$ git clone https://github.<span class="property">com</span>/<span class="type">JohnSundell</span>/<span class="type">Publish</span>.<span class="property">git</span>
$ cd <span class="type">Publish</span>
$ make
$ mkdir <span class="type">Leonte</span>.<span class="property">dev</span>
$ cd <span class="type">Leonte</span>.<span class="property">dev</span>
$ publish new
$ <span class="keyword">open</span> <span class="type">Package</span>.<span class="property">swift</span>
</code></pre><p>Run (CMD+R) the project. It will create an Output folder</p><h2>Run a local HTTP server</h2><pre><code>$ cd <span class="type">Output</span>
$ python -m <span class="type">SimpleHTTPServer</span> <span class="number">8080</span>
</code></pre><p>Now open http://localhost:8080/ in a browser to see your 'Hello World!' website.</p><h2>Start customizing your website</h2><p>In Xcode, open Sources &gt; Leontedev &gt; main.swift</p><p>Modify the struct's properties to customize your website.</p><pre><code><span class="keyword">struct</span> Leontedev: <span class="type">Website</span> {
</code></pre><p>You'll also want to create your own theme. I made a copy of the theme that comes built-in and worked on that one.</p><p>You can get inspiration from my own implementation: <a href="https://github.com/leontedev/Publish-leonte.dev">https://github.com/leontedev/Publish-leonte.dev</a></p>]]></content:encoded></item></channel></rss>