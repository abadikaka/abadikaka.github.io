<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8"/>
		<meta name="og:site_name" content="🧔🏻 Michael Abadi S. | 🍎 iOS Engineer | 🏠 Bangkok, 🇹🇭 Thailand | 🇲🇨 Indonesian"/>
		<link rel="canonical" href="https://michaelabadi.com/articles/Build-Builder-Pattern-Swift"/>
		<meta name="twitter:url" content="https://michaelabadi.com/articles/Build-Builder-Pattern-Swift"/>
		<meta name="og:url" content="https://michaelabadi.com/articles/Build-Builder-Pattern-Swift"/>
		<title>Bake a Builder Pattern in iOS | 🧔🏻 Michael Abadi S. | 🍎 iOS Engineer | 🏠 Bangkok, 🇹🇭 Thailand | 🇲🇨 Indonesian</title>
		<meta name="twitter:title" content="Bake a Builder Pattern in iOS | 🧔🏻 Michael Abadi S. | 🍎 iOS Engineer | 🏠 Bangkok, 🇹🇭 Thailand | 🇲🇨 Indonesian"/>
		<meta name="og:title" content="Bake a Builder Pattern in iOS | 🧔🏻 Michael Abadi S. | 🍎 iOS Engineer | 🏠 Bangkok, 🇹🇭 Thailand | 🇲🇨 Indonesian"/>
		<meta name="description" content="Bake a Builder Pattern in iOS."/>
		<meta name="twitter:description" content="Bake a Builder Pattern in iOS."/>
		<meta name="og:description" content="Bake a Builder Pattern in iOS."/>
		<meta name="twitter:card" content="summary"/>
		<link rel="stylesheet" href="/styles.css" type="text/css"/>
		<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
		<link rel="shortcut icon" href="/images/favicon.png" type="image/png"/>
		<link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to 🧔🏻 Michael Abadi S. | 🍎 iOS Engineer | 🏠 Bangkok, 🇹🇭 Thailand | 🇲🇨 Indonesian"/>
	</head>
	<body class="item-page">
		<header>
			<div class="wrapper">
				<a class="site-name" href="/">🧔🏻 Michael Abadi S. | 🍎 iOS Engineer | 🏠 Bangkok, 🇹🇭 Thailand | 🇲🇨 Indonesian</a>
				<h4>Welcome to the official web of Michael</h4>
				<nav>
					<ul>
						<li>
							<a href="/">Home</a>
						</li>
						<li class="selected">
							<a href="/articles">Articles</a>
						</li>
						<li>
							<a href="/projects">Projects</a>
						</li>
						<li>
							<a href="/talks">Talks &amp; E-Book</a>
						</li>
						<li>
							<a href="/#aboutMeAnchor">About</a>
						</li>
					</ul>
				</nav>
			</div>
		</header>
		<div class="wrapper">
			<article>
				<div class="content"><h1>Bake a Builder Pattern in iOS</h1><h3>Medium : <a href="https://medium.com/macoclock/bake-a-builder-pattern-in-ios-4684a3a7c71a">Bake Builder Pattern</a></h3><p>Have you ever have a problem when designing a system that has a similar foundation and capabilities however the ingredients to form the object would vary? We may end up with an easy solution by providing different parameters for each subclass. However, multiple subclasses that need to override the constructor might also have to own those unnecessary properties into its interface. There is one design pattern that also considered as Creational Design Pattern which Android Design pattern by default having this pattern. It called as Builder Pattern.</p><p>Of course, there are many ways to make it work on iOS. Let understanding the basic with what is Builder Pattern. Builder is a creational design pattern that lets you construct objects step by step per user requirement. The pattern allows you to produce different types and representations of an object using the same construction code. It refers to a declarative way to construct an object. Builder pattern can be included as Reactive Programming as well!</p><p>Let start with the common problem, “A Car Company”. Company “A” is a big brand company and it has multiple products to be made. This company will make a “CarA” until “CarE”. They do have 5 types of cars, start from a car with a single door, sports car, family car, SUV, and a truck. We can achieve this easily by extend a “Car” base class and has the subclasses to override the necessary function, but we will end up with tons of subclasses and, and new parameters and more and more. We can simplify it by having one Base Class that owns a huge constructor, however, those subclasses need to override the constructor with all of the parameters from possible combinations. The constructor with lots of parameters has its downside, not all the parameters are needed at all times.</p><h2><strong>SOLUTION: BUILDER PATTERN (THE CAR CONCEPT)</strong></h2><p>Yep, by using a builder pattern we eliminate that construction logic. The pattern will extract and define the behavior of construction into steps. We may have buildDoors, buildWheels, buildEngine, buildColor, buildExhaust. We don’t need to call every step if we don’t need it. If we do need to have another builder for another type of car with a different implementation of each step, we can make different builders and implement it in a different way!. For example, imagine a builder that builds a car from 4 sports wheel and 2 doors, a second one that builds everything with 4 normal wheel and 4 doors and a third one that uses 2 doors and a big wheel. By calling the same set of steps, you get a sports car from the first builder, a normal family car from the second, and a Sport SUV from the third. However, this would only work if the client code that calls the building steps is able to interact with builders using a common interface. We also able to escalate this by having another Manager class to manage the specific builder of the process of creating the car in the company</p><h2><strong>CODE</strong></h2><ol><li>Declarative Way</li></ol><pre><code><span class="comment">// This one is a SportCarBuilder for building a sport car
// We just need two properties of wheel and color that can be added and modified
// However for engine and door has been defined by SportCar class</span>
<span class="keyword">final class</span> SportCarBuilder {

    <span class="keyword">private var</span> wheel: <span class="type">Wheel</span> = <span class="type">Wheel</span>(type: .<span class="call">racing</span>(tyre20))
    <span class="keyword">private var</span> color: <span class="type">Color</span> = <span class="type">Color</span>(.<span class="dotAccess">red</span>)

    <span class="keyword">func</span> withColor(color: <span class="type">UIColor</span>) {
      <span class="keyword">self</span>.<span class="property">color</span> = <span class="type">Color</span>(color) 
    }
    
    <span class="keyword">func</span> withWheel(type: <span class="type">WheelType</span>) {
      <span class="keyword">self</span>.<span class="property">wheel</span> = <span class="type">Wheel</span>(type: type)
    }
    
    <span class="keyword">func</span> build() -&gt; <span class="type">SportCar</span> {
        <span class="keyword">return</span> <span class="type">SportCar</span>(wheel: wheel, color: color)
    }
}

<span class="comment">// This one is a SportCar class that subclass of the Car base class
// Car base class has 4 properties, this class will initialize through the base class with designated parameters that we define for SportCar</span>
<span class="keyword">final class</span> SportCar: <span class="type">Car</span> {
  <span class="keyword">init</span>(wheel: <span class="type">Wheel</span>, color: <span class="type">Color</span>) {
    <span class="keyword">super</span>.<span class="keyword">init</span>(doors: <span class="type">Door</span>(<span class="number">2</span>), engine: <span class="type">Engine</span>(<span class="type">V85000</span>), wheel: wheel, color: color)
  }
}

<span class="comment">// How to call :</span>
<span class="keyword">let</span> sportCar = <span class="type">SportCarBuilder</span>()
                .<span class="call">withColor</span>(color: .<span class="dotAccess">red</span>)
                .<span class="call">withWheel</span>(type: .<span class="dotAccess">normal</span>)
                .<span class="call">build</span>()
                
<span class="comment">// sportCar.wheel === .normal --&gt; Defined by user
// sportCar.engine === Engine(V85000) --&gt; Defined by SportCar implementation</span>
</code></pre><p>In the above code, it is pretty clear that when we want to get the sportCar Object, we can easily call the builder and add the necessary requirement/modifier into the builder. This way we are defining the behavior of what we want to the builder (declarative) without intervening with the implementation. SportCar also hides the Engine and Door properties from the Car base class because it will automatically be adjusted in the SportCar class instead.</p><ol><li>Closure / Block</li></ol><pre><code><span class="comment">// We reuse the above SportCarBuilder, we just change some interface
// Notice we instead are using the block for update the necessary properties</span>
<span class="keyword">class</span> SportCar {
  <span class="keyword">typealias</span> Builder = (builder: <span class="type">SportCarBuilder</span>) -&gt; <span class="type">Void</span>

  <span class="keyword">private init</span>(builder: <span class="type">SportCarBuilder</span>) {
    <span class="keyword">super</span>.<span class="keyword">init</span>(doors: <span class="type">Door</span>(<span class="number">2</span>), engine: <span class="type">Engine</span>(<span class="type">V85000</span>), wheel: builder.<span class="property">wheel</span>, color: builder.<span class="property">color</span>)
  }

  <span class="keyword">static func</span> make(with builderBlock: <span class="type">Builder</span>) -&gt; <span class="type">SportCar</span> {
    <span class="keyword">let</span> builder = <span class="type">SportCarBuilder</span>()
    <span class="call">builderBlock</span>(builder)
    <span class="keyword">return</span> <span class="type">SportCar</span>(builder: builder)
  }
}

<span class="comment">// This is the way we will use by defining the properties inside the block</span>
<span class="keyword">let</span> sportCar = <span class="type">SportCar</span>.<span class="call">make</span> { builder <span class="keyword">in</span>
  builder.<span class="property">color</span> = .<span class="dotAccess">red</span>
  builder.<span class="property">wheel</span> = .<span class="dotAccess">racing</span>
}
</code></pre><p>In the above code it is pretty straight forward, we will define the behavior we want through the completion block when we call the make function inside SportCar class. In most cases, the second way is used by Objective-C developer.</p><ol start="3"><li>Constructor Injection</li></ol><pre><code><span class="comment">// This is the base Car class that has all of the foundation materials to make a Car</span>
<span class="keyword">class</span> Car {
  <span class="keyword">let</span> doors: <span class="type">Door</span>
  <span class="keyword">let</span> wheel: <span class="type">Wheel</span>
  <span class="keyword">let</span> engine: <span class="type">Engine</span>
  <span class="keyword">let</span> color: <span class="type">Color</span>
  
  <span class="keyword">func</span> buildCar() -&gt; <span class="type">Car</span>
}

<span class="comment">// This is the subclass of Car which is a SportCar that has a private initializer
// Only bake the Car with the builder using a static function, however you can omit the static one and immediate using the constructor as well (your preference)</span>
<span class="keyword">final class</span> SportCar: <span class="type">Car</span> {
  <span class="keyword">private init</span>(builder: <span class="type">SportCarBuilder</span>) {
    <span class="keyword">let</span> door = <span class="type">Door</span>(<span class="number">2</span>)
    <span class="keyword">let</span> engine = <span class="type">Engine</span>(<span class="type">V85000</span>)
    <span class="keyword">let</span> wheel = builder.<span class="property">wheel</span>
    <span class="keyword">let</span> color = builder.<span class="property">color</span>
    <span class="keyword">super</span>.<span class="keyword">init</span>(doors: door, engine: engine, wheel: wheel, color: color)
  }
  
  <span class="keyword">static func</span> make(with builder: <span class="type">SportCarBuilder</span>) -&gt; <span class="type">SportCar</span> {
    <span class="keyword">return</span> <span class="type">SportCar</span>(builder: builder)
  }
}

<span class="comment">// This is the SportCarBuilder that just need color and wheel because the engine and the door will be automatically adjusted on the class who will use this by default</span>
<span class="keyword">struct</span> SportCarBuilder {
  <span class="keyword">let</span> color: <span class="type">Color</span>
  <span class="keyword">let</span> wheel: <span class="type">Wheel</span>
}

<span class="comment">// This is the factory class for creating the necessary car on the company
// User will just need this class to retrieve the final product they need</span>
<span class="keyword">final class</span> CarFactory {
  
  <span class="keyword">func</span> sportCar(with builder: <span class="type">SportCarBuilder</span>) -&gt; <span class="type">SportCar</span> {
    <span class="keyword">return</span> <span class="type">SportCar</span>.<span class="call">make</span>(builder: builder)
  }
  
  <span class="keyword">func</span> truckCar(with builder: <span class="type">TruckCarBuilder</span>) -&gt; <span class="type">TruckCar</span> {
    <span class="keyword">return</span> <span class="type">TruckCar</span>.<span class="call">make</span>(builder: builder)
  }
  
  <span class="keyword">func</span> SUVCar(with builder: <span class="type">SUVCarBuilder</span>) -&gt; <span class="type">SUVCar</span> {
    <span class="keyword">return</span> <span class="type">SUVCar</span>.<span class="call">make</span>(builder: builder)
  }
  
  <span class="keyword">func</span> familyCar(with builder: <span class="type">FamilyCarBuilder</span>) -&gt; <span class="type">FamilyCar</span> {
    <span class="keyword">return</span> <span class="type">FamilyCar</span>.<span class="call">make</span>(builder: builder)
  }
}
</code></pre><p>In the code above we can see that we do have CarFactory as a factory object that generates each car base on the Builder that the user wants to inject into the parameters. The user creates the necessary builder through their required constructor on the specific builder. SportCarBuilder doesn’t have engine properties because in the SportCar object that consumes the builder will automatically adjust the engine with the required engine only for a sport car. This way the specific requirement has been handled properly by the SportCar class.</p><p>Finally the conclusion, the goal of the builder pattern is to reduce the need to keep mutable state — resulting in objects that are simpler and generally more predictable. By enabling objects to become stateless, they are usually much easier to test and debug — since their logic consists only of “pure” input &amp; output. There are other multiple pros to use the builder pattern, even though this is not iOS Common design pattern but we can achieve it. Remember, there is also some stuff to be considered before we go with the builder pattern. I will let you guys decide whether it is worth it or not for using this pattern on your project.</p><h3>Reference<br />:</h3><ol><li>https://refactoring.guru/design-patterns/builder/swift/example</li><li>https://spin.atomicobject.com/2015/11/02/objective-c-value-objects-mantle/</li><li>https://www.swiftbysundell.com/articles/using-the-builder-pattern-in-swift/</li></ol></div>
				<br/>
				<br/>
				<p>Published on 2020-10-18 14:00:00 +0000</p>
				<span>Tagged with: </span>
				<ul class="tag-list">
					<li>
						<a href="/tags/ios-dev">iOS Dev</a>
					</li>
					<li>
						<a href="/tags/design-pattern">Design Pattern</a>
					</li>
					<li>
						<a href="/tags/builder">Builder</a>
					</li>
					<li>
						<a href="/tags/swift">Swift</a>
					</li>
				</ul>
			</article>
		</div>
		<footer>
			<p>Written in Swift. Made with 
				<a href="https://github.com/johnsundell/ink">Ink</a>, 
				<a href="https://github.com/johnsundell/plot">Plot</a>, 
				<a href="https://github.com/johnsundell/splash">Splash</a> &amp; 
				<a href="https://github.com/johnsundell/publish">Publish</a> Inspired by theme from
				<a href="https://github.com/leontedev/Publish-leonte.dev">leontedev</a>.
			</p>
			<p>©2020 Michael Abadi Santoso</p>
			<p>
				<a class="rss" href="/feed.rss">RSS</a>
			</p>
		</footer>
	</body>
</html>